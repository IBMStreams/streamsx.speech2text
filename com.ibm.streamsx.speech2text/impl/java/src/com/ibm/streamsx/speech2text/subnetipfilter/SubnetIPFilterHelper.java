/* Generated by Streams Studio: December 14, 2016 at 2:37:37 PM GMT+5:30 */
package com.ibm.streamsx.speech2text.subnetipfilter;

import java.util.StringTokenizer;

import org.apache.commons.net.util.SubnetUtils;
import org.apache.log4j.Logger;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.OutputPortSet.WindowPunctuationOutputMode;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;
import java.util.HashMap;

/**
 * Class for an operator that receives a tuple and then optionally submits a tuple.
 * This pattern supports one or more input streams and one or more output streams.
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li>
 * <li>process() handles a tuple arriving on an input port
 * <li>processPuncuation() handles a punctuation mark arriving on an input port
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time,
 * such as a request to stop a PE or cancel a job.
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks,
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other,
 * which lead to these methods being called concurrently by different threads.</p>
 */
@PrimitiveOperator(name="SubnetIPFilterHelpers",
description="Java Operator SubnetIPFilter")
@InputPorts({@InputPortSet(description="Port that ingests tuples", cardinality=1, optional=false, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious), @InputPortSet(description="Optional input ports", optional=true, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious)})
@OutputPorts({@OutputPortSet(description="Port that produces tuples", cardinality=1, optional=false, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating), @OutputPortSet(description="Optional output ports", optional=true, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating)})
@Libraries({ "opt/downloaded/*" })
public class SubnetIPFilterHelper extends AbstractOperator {

        static SubnetUtils[] arrayOfSubnets = null;
        HashMap IPTable = null;
    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
        @Override
        public synchronized void initialize(OperatorContext context)
                        throws Exception {
        // Must call super.initialize(context) to correctly setup an operator.
                super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );

        // TODO:
        // If needed, insert code to establish connections or resources to communicate an external system or data store.
        // The configuration information for this may come from parameters supplied to the operator invocation,
        // or external configuration files or a combination of the two
		String filters = getSubnets();
		StringTokenizer filterTokenizer=  new StringTokenizer(filters, "|");
		String[] arrayOfFilterTypes = new String[2];
		int indexI=0;
		while (filterTokenizer.hasMoreTokens()) {
				arrayOfFilterTypes[indexI] = filterTokenizer.nextToken();
				indexI++;
		}


        String listOfSubnets =  arrayOfFilterTypes[0]; //"10.241.49.0/24,10.241.53.0/24,10.241.11.0/24";
        String listOfIPs = arrayOfFilterTypes[1];

		if ( (listOfSubnets != null) &&  !(listOfSubnets.equalsIgnoreCase("NULL")) ) {
                StringTokenizer tokenizer=  new StringTokenizer(listOfSubnets, ",");
                int numOfTokens = tokenizer.countTokens();
                arrayOfSubnets = new SubnetUtils[numOfTokens];
                int i = 0;
                while (tokenizer.hasMoreTokens()) {
                        arrayOfSubnets[i] = new SubnetUtils(tokenizer.nextToken());
                        i++;
                }
        }// end of listOfSubnects check

        if (arrayOfFilterTypes[1] !=null) {
			IPTable = new HashMap();

			StringTokenizer IPTokenizer=  new StringTokenizer(arrayOfFilterTypes[1], ",");
			while (IPTokenizer.hasMoreTokens()) {
				StringTokenizer tokenizer = new StringTokenizer(IPTokenizer.nextToken(), ":");
				String ipAddress = tokenizer.nextToken();
				String port = (tokenizer.hasMoreTokens() ? tokenizer.nextToken() : "*");
				IPTable.put(ipAddress, port);
			}
        }// end of IPList check

        }

    /**
     * Notification that initialization is complete and all input and output ports
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
        // This method is commonly used by source operators.
        // Operators that process incoming tuples generally do not need this notification.
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    }

    /**
     * Process an incoming tuple that arrived on the specified port.
     * <P>
     * Copy the incoming tuple to a new output tuple and submit to the output port.
     * </P>
     * @param inputStream Port the tuple is arriving on.
     * @param tuple Object representing the incoming tuple.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public final void process(StreamingInput<Tuple> inputStream, Tuple tuple)
            throws Exception {

        // Create a new tuple for output port 0
        StreamingOutput<OutputTuple> outStream = getOutput(0);

        String addr = tuple.getString("ipSrc_addr");
        short port = tuple.getShort("dstPort");
        
        boolean validIPFlag = false;
        // First check against specific IP list.
        if ( IPTable != null ) {
        	String validPort = (String)IPTable.get(addr);
                if ((validPort != null) && (validPort.equals("*") || validPort.equals(String.valueOf(port))))
                        validIPFlag=true;
        }


        // Run SubNet filtering if validIPFlag is false;
        if (!validIPFlag) {
                if (arrayOfSubnets != null) {

                        for(SubnetUtils validAddress : arrayOfSubnets) {
                    if(validAddress.getInfo().isInRange(addr)) {
                        validIPFlag=true;
                        break;
                    }
                }
                }
        }
        // ip filter logic.

        // Copy across all matching attributes if valid IP found
        if (validIPFlag) {
                OutputTuple outTuple = outStream.newTuple();
                        outTuple.assign(tuple);
                        outStream.submit(outTuple);
        }

        // TODO: Insert code to perform transformation on output tuple as needed:
        // outTuple.setString("AttributeName", "AttributeValue");

        // Submit new tuple to output port 0

    }

    /**
     * Process an incoming punctuation that arrived on the specified port.
     * @param stream Port the punctuation is arriving on.
     * @param mark The punctuation mark
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public void processPunctuation(StreamingInput<Tuple> stream,
                Punctuation mark) throws Exception {
        // For window markers, punctuate all output ports
        super.processPunctuation(stream, mark);
    }

    /**
     * Shutdown this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );

        // TODO: If needed, close connections or release resources related to any external system or data store.

        // Must call super.shutdown()
        super.shutdown();
    }

    String subnets;

    public String getSubnets() {
                return subnets;
        }

        @Parameter(name = "subnets", optional = false)
        public void setSubnets(String subnets) {
                this.subnets = subnets;
        }
}
